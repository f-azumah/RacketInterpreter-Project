# Scheme Interpreter

In this project I built an interpreter for a Turing-complete
subset of Racket/Scheme, including lambdas `if`, `let`, `let*`,
`and`/`or`, and a set of ten primitives over numbers and lists.


## The Language: Syntax

Below is the full syntax of the language supported:

```
Primitives
prim = {+, -, *, =, equal?, cons, car, cdr, list, null?}

x is a metavariable
exp ::= (lambda (x ...) exp)         -- Fixed-arity lambda
      | (let ([x0 exp0] ...) exp)    -- let-binding
      | (let* ([x0 exp0] ...) exp)   -- "Sequenced" let
      | (and e0 ...)                 -- Polyadic and (0 or more args)
      | (or e0 ...)                  -- Polyadic or (0 or more args)
      | (exp0 ...)                   -- Function application
      | datum                        -- Datums


datum:
  | '()                              -- Empty list
  | n                                -- Literal numbers
  | #t | #f                          -- Literal booleans
```

This interpreter, `interp-ce`, interprets any valid `scheme-ir?`  
program and yields the same value as it would in DrRacket,
except for closures (generated by lambdas) which are represented
as `'(closure ,lambda ,environment)`. For example, `(+ 1 2)`
evaluates to `3`, and `(cons 1 (cons 2 '()))` yields `'(1 2)`. For
programs that result in a runtime error, it returns `(error
,message)---giving some reasonable string error message.


## Builtin Functions

My solution to supporting built-in functions takes the following strategy:
construct the initial environment so that it maps each builtin to a closure 
(with an empty environment) that looks something like `'(lambda primargs 
(apply-prim, op primargs)`, where `op` is the relevant primitive. This then
naturally gets applied by `interp-ce`, where I add a special case for
`apply-prim` (*not* a scheme-ir? expression), which uses Racket's
`apply` to apply the necessary function (obtained via either `(eval op
(make-base-namespace))`, or something like `(hash-ref op (hash '+ +
...))`).


